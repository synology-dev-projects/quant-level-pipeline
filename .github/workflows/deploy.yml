name: Branch-Based Deployment Pipeline

# 1. RUN ON ALL BRANCHES
on:
  push:
    # This wildcard runs the workflow for 'develop', 'master', 'develop2', etc.
    branches: [ "**" ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  deploy-branch:
    runs-on: self-hosted

    steps:
      # --- SETUP ---
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Load Synology Paths
        run: |
          # Internal Runner Path (Unchanged)
          cat ../../conf/syno_paths.env >> $GITHUB_ENV

      - name: Install Dependencies
        run: |
          # 1. Check if .venv exists
          if [ ! -d ".venv" ]; then
            echo "Creating virtual environment..."
            
            echo "Python version" 
            python3 -m venv .venv
          else
            echo "Virtual environment found."
          fi
          
          # 2. Activate specifically for this step to install requirements
          source .venv/bin/activate
          
          pip install --upgrade pip
          pip install -r requirements.txt
          
          # 3. CRITICAL: Add venv to GITHUB_PATH
          # This ensures the 'verify.sh' step later uses this python/pytest automatically
          echo "$PWD/.venv/bin" >> $GITHUB_PATH

      # --- DYNAMIC DEPLOYMENT ---
      - name: Deploy to Branch Folder
        run: |
          # 1. Get the branch name (e.g., 'develop', 'master', 'develop2')
          BRANCH_NAME="${{ github.ref_name }}"
          REPO_NAME="${{ github.event.repository.name }}"
          
          # 2. Construct the Dynamic Path
          # Format: git-repos/{BRANCH}/{REPO}
          # Example: /volume2/.../git-repos/develop/quant-level-pipeline
          TARGET_PATH="${{ env.SYNOLOGY_ROOT_PATH }}/${BRANCH_NAME}/${REPO_NAME}"
          
          echo "ðŸ“‚ Branch detected: $BRANCH_NAME"
          echo "ðŸš€ Deploying to: $TARGET_PATH"
          
          # 3. Create directory and copy
          mkdir -p "$TARGET_PATH"
          cp -ru src/ "$TARGET_PATH/"
          cp -ru tests/ "$TARGET_PATH/"
          cp verify.sh "$TARGET_PATH/"
          
          # 4. Save path for the verification step
          echo "DEPLOY_DIR=$TARGET_PATH" >> $GITHUB_ENV

      # --- SECRET INJECTION (The Security Layer) ---
      - name: Create Runtime .env File
        run: |
          # This writes the .env file directly into the deployment folder
          ENV_FILE="${{ env.DEPLOY_DIR }}/.env"
          
          echo "Generating secure .env file at $ENV_FILE..."
          
          # Inject secrets from GitHub Vault
          echo "ORACLE_USER=${{ secrets.ORACLE_USER }}" > "$ENV_FILE"
          echo "ORACLE_PASSWORD=${{ secrets.ORACLE_PASS }}" >> "$ENV_FILE"
          echo "ORACLE_HOST_IP=${{ secrets.ORACLE_HOST_IP }}" >> "$ENV_FILE"
          echo "ORACLE_SERVICE=${{ secrets.ORACLE_SERVICE }}" >> "$ENV_FILE"
          
          # Lock it down (Owner Read/Write only)
          chmod 600 "$ENV_FILE"

      # --- VERIFICATION ---
      - name: Run Verification
        run: |
          echo "ðŸ§ª Testing branch: ${{ github.ref_name }}"
          cd "${{ env.DEPLOY_DIR }}"
          chmod +x verify.sh
          ./verify.sh

      # --- CONDITIONAL MERGE (Only for 'develop') ---
      # If we are on 'develop' and tests passed, merge to 'master'.
      # This push to 'master' will trigger this workflow AGAIN to deploy the master folder.
      - name: Auto-Promote to Master
        if: github.ref_name == 'develop'
        run: |
          echo "âœ… Develop verified. Promoting to Master..."
          
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          git fetch origin develop
          git checkout master
          git pull origin master
          
          # Merge and Push
          git merge origin/develop --no-ff -m "Auto-merge develop to master [Skip CI]"
          git push origin master